import {
  addDoc,
  collection,
  deleteDoc,
  doc,
  getDoc,
  query,
  setDoc,
  updateDoc,
  where,
} from 'firebase/firestore';
import { useCollectionData } from 'react-firebase-hooks/firestore';
import useFirebase from '../../../providers/useFirebase';
import { STORE_COLLECTIONS } from '../../../shared/Constants';
import { genericConverter } from '../../../shared/Converters';
import { ChannelEntity, UserProfile } from '../../../shared/Types';
import { authUserToProfile } from '../../../shared/Utils';

export const useOwnChannel = (channelId: string) => {
  const { store } = useFirebase();

  const channelRef = collection(store!, STORE_COLLECTIONS.CHANNELS.ROOT).withConverter(
    genericConverter
  );

  const admissionRequestsRef = collection(
    channelRef,
    channelId,
    STORE_COLLECTIONS.CHANNELS.ADMISSION_REQUESTS
  );

  const membersRef = collection(channelRef, channelId, STORE_COLLECTIONS.CHANNELS.MEMBERS);

  const bannedUsersRef = collection(channelRef, channelId, STORE_COLLECTIONS.CHANNELS.BANS);

  const [admissionRequests] = useCollectionData(admissionRequestsRef);
  const [members] = useCollectionData(membersRef);
  const [bannedUsers] = useCollectionData(bannedUsersRef);

  const confirmChannelPermissionRequest = async (newUser: UserProfile) => {
    // CREATING A FIREBASE SUBCOLLECTION WITH AN AUTOGENERATED ID
    // await addDoc(
    //   collection(store!, STORE_COLLECTIONS.CHANNELS.ROOT, channelId, 'users'),
    //   newUser
    // );

    await setDoc(
      doc(
        store!,
        STORE_COLLECTIONS.CHANNELS.ROOT,
        channelId,
        STORE_COLLECTIONS.CHANNELS.MEMBERS,
        newUser.uid
      ),
      newUser
    );

    await deleteDoc(
      doc(
        store!,
        STORE_COLLECTIONS.CHANNELS.ROOT,
        channelId,
        STORE_COLLECTIONS.CHANNELS.ADMISSION_REQUESTS,
        newUser.uid
      )
    );
  };

  const banUserFromChannel = async (bannedUser: UserProfile) => {
    const userRef = doc(
      store!,
      STORE_COLLECTIONS.CHANNELS.ROOT,
      channelId,
      STORE_COLLECTIONS.CHANNELS.MEMBERS,
      bannedUser.uid!
    );

    await setDoc(
      doc(
        store!,
        STORE_COLLECTIONS.CHANNELS.ROOT,
        channelId,
        STORE_COLLECTIONS.CHANNELS.BANS,
        bannedUser.uid!
      ),
      bannedUser
    );
    await deleteDoc(userRef);
  };

  const unbanUserFromChannel = async (bannedUser: UserProfile) => {
    const bannedRef = doc(
      store!,
      STORE_COLLECTIONS.CHANNELS.ROOT,
      channelId,
      STORE_COLLECTIONS.CHANNELS.BANS,
      bannedUser.uid!
    );

    await setDoc(
      doc(
        store!,
        STORE_COLLECTIONS.CHANNELS.ROOT,
        channelId,
        STORE_COLLECTIONS.CHANNELS.MEMBERS,
        bannedUser.uid
      ),
      bannedUser
    );

    await deleteDoc(bannedRef);
  };

  const kickUserFromChannel = async (userId: string) => {
    const userRef = doc(
      store!,
      STORE_COLLECTIONS.CHANNELS.ROOT,
      channelId,
      STORE_COLLECTIONS.CHANNELS.MEMBERS,
      userId
    );

    await deleteDoc(userRef);
  };

  return {
    admissionRequests: admissionRequests as UserProfile[],
    members: members as UserProfile[],
    bannedUsers: bannedUsers as UserProfile[],
    confirmChannelPermissionRequest,
    banUserFromChannel,
    unbanUserFromChannel,
    kickUserFromChannel,
  };
};

export default function useOwnChannels() {
  const { store, user } = useFirebase();

  const channelsRef = collection(store!, STORE_COLLECTIONS.CHANNELS.ROOT).withConverter(
    genericConverter
  );

  const q = query<ChannelEntity>(channelsRef, where('admin.uid', '==', user?.uid));
  const [channels] = useCollectionData<ChannelEntity>(q);

  const createChannel = (data: Omit<ChannelEntity, 'admin'>) => {
    addDoc<ChannelEntity>(channelsRef, { ...data, admin: authUserToProfile(user!) });
  };

  const confirmDenyChannelPermissionRequest = async (newUser: UserProfile, channelId: string) => {
    const channelSnapshot = doc(store!, STORE_COLLECTIONS.CHANNELS.ROOT, channelId);
    const channelRef = await getDoc(channelSnapshot);
    const channelEntity = channelRef.data() as ChannelEntity;
    // await updateDoc(channelSnapshot, {
    //   admissionRequests: channelEntity.admissionRequests.filter(
    //     request => request.uid !== newUser?.uid
    //   ),
    // });
  };

  return {
    channels,
    createChannel,

    confirmDenyChannelPermissionRequest,
  };
}
